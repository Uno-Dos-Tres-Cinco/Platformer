<!DOCTYPE html>
<html>


<head>
   <title>L</title>
   <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>


<body>


   <script>


       var config = {
           type: Phaser.AUTO,
           width: 1700,
           height: 900,
           backgroundColor: '#658cf0',
           physics: {
               default: 'arcade',
           },


           scene: {
               preload: preload,
               create: create,
               update: update,
           }


       };


       class Player extends Phaser.Physics.Arcade.Sprite {
           constructor(scene, x, y) {
               super(scene, x, y, 'player');
               scene.add.existing(this);
               scene.physics.add.existing(this);
               this.setScale(2);
               this.setCollideWorldBounds(false);
               this.setGravityY(3000); // We will set gravity *per object* rather than for the scene!
           }
       }


       var game = new Phaser.Game(config);


       // Game Objects
       var platforms;
       var player;


       // Keyboard controls
       var cursors;
       var keys;
       var space;
       var level = 0;
       var jumpBuffer = 0;
       var coyoteFrames = 0;


       function preload() {
           // this.load.image('sky', 'assets/clouds.png');
           this.load.image('platform', 'assets/platform.png');
           this.load.image('player', 'assets/player.png');
           this.load.image('grass', 'assets/grass.png');
           this.load.image('mountains', 'assets/mountains.png');
           this.load.image('stud', 'assets/stud.png');
           this.load.image('vertPlat', 'assets/vertical_platform.png');
       }


       function create() {
           // Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
           // let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);


           // Create the platforms and the player character set to collide with the platforms
           this.mountains = this.add.tileSprite(850,
               450,
               this.game.scale.width,
               this.game.scale.height,
               'mountains'
           );
           createPlatforms(this, level);


           player = new Player(this, 400, 400);
           this.physics.add.collider(player, platforms);
           //this.physics.add.collider(player, fallingPlatforms);
           //this.physics.add.collider(player, instantFallPlatforms);

           // Set up user input
           cursors = this.input.keyboard.createCursorKeys();
           keys = this.input.keyboard.addKeys('A, D');
           //upW = this.input.keyboard.addKeys('W');
           space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
           space.on('down', jump); // calls jump function when space is pressed
           //upW.on('down', jump);

           this.grass = this.add.tileSprite(0,
               1515,
               this.game.scale.width * 2,
               this.game.scale.height * 2,
               'grass'
           );


           // Configure the camera to follow the player only vertically
           this.cameras.main.startFollow(player);
       }


       function createPlatforms(scene, level) {
           platforms = scene.physics.add.staticGroup();


           // basePlatform is the floor of the game
           let basePlatform = platforms.create(game.scale.width / 2, game.scale.height - 30, 'platform');
           if (level === 0) {
               basePlatform.setScale(10, 1).refreshBody(); // scales the base platform in the x axis to cover the entire floor


               platforms.create(600, 650, 'platform'); // creates the upper left platform
               platforms.create(950, 750, 'platform'); // creates the bottom right platform
               platforms.create(300, 550, 'platform');
               platforms.create(100, 400, 'platform');
               platforms.create(300, 250, 'platform');
               platforms.create(500, 125, 'platform');
               platforms.create(900, 0, 'platform');
               platforms.create(1300, -125, 'platform');
               platforms.create(1300, -275, 'platform');
               platforms.create(900, -300, 'stud');
               platforms.create(700, -350, 'stud');
               platforms.create(500, -450, 'stud');
               platforms.create(500, -600, 'stud');
               platforms.create(300, -600, 'vertPlat');
               platforms.create(300, -900, 'vertPlat');
               platforms.create(268, -850, 'stud');
           }
       }


       function update() {
           // Player will not move in the x-axis unless a movement key is being pressed
           player.setVelocityX(0);


           // Player has "drag" on the x-axis meaning they slide a bit after an input
           player.setDragX(1000);


           // Handle player movements
           if (cursors.left.isDown || keys.A.isDown) {
               player.setVelocityX(-400);
           }


           if (cursors.right.isDown || keys.D.isDown) {
               player.setVelocityX(400);
           }


           if (player.body.touching.down) {
               coyoteFrames = 8;
           }
           
           if ((player.body.touching.down || coyoteFrames > 0) && jumpBuffer > 0) {
               // If the player is on the ground, the player can jump
               player.setVelocityY(-1100);
               jumpBuffer = 0;
               coyoteFrames = 0;
           }
           
           if (jumpBuffer > 0) {
               jumpBuffer--;
           }
           
           if (coyoteFrames > 0) {
               coyoteFrames--;
           }
           
           

       }


       function jump(event) {
           if (player.body.touching.down || coyoteFrames > 0) {
               // If the player is on the ground, the player can jump
               player.setVelocityY(-1100);
               coyoteFrames = 0;
           } else {
               jumpBuffer = 8;
           }
       }


   </script>


</body>


</html>
